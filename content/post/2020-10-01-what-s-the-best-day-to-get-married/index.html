---
title: What's The Best Day to Get Married?
author: JLaw
date: '2020-10-01'
slug: what-s-the-best-day-to-get-married
categories:
  - R
  - VennDiagram
  - Dates
tags:
  - eulerr
  - lubridate
subtitle: ''
summary: ''
authors: []
lastmod: '2020-10-01T05:27:43-04:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<div id="tldr" class="section level1">
<h1>TL;DR</h1>
<ul>
<li>There really <strong>isnâ€™t</strong> a best day to get married as there isnâ€™t much differentiation between various days. Both as part of this analysis and in life. Do whatâ€™s best for you and your relationship.</li>
<li>However, if <strong>ALL</strong> you care about is both being married on a Saturday, maximizing the number of times your anniversary will fall on a Saturday, and maximizing the number of â€œbigâ€ anniversaries that fall on a Saturday then avoid the 24 months after a leap day!</li>
</ul>
</div>
<div id="the-original-objective-of-this-analysis" class="section level1">
<h1>The original objective of this analysis</h1>
<p>Having somewhat recently celebrated a 5th anniversary on a Saturday (ğŸ¥‚), Mrs.Â JLaw asked â€œHow many anniversaries will we have on a Saturday?â€ and â€œWhen is the next big one that weâ€™ll have?â€. Upon finding out that our next â€œbigâ€ Saturday anniversary wonâ€™t come until our 50th, she suggested that I look into whether certain days would have been best to have gotten married.</p>
<p>In actually looking into this analysis, thereâ€™s not that much difference in the number of Saturdays or â€œbigâ€ Saturdays regardless of wedding date.</p>
<p>So the initial question was, <strong><em>what are the BEST and WORST dates to get married</em></strong> when optimizing for <em>maximizing the number of â€œbigâ€ (multiples of 5) anniversaries occurring on a Saturday</em>. The constraints being that the initial wedding date ALSO needed to be a on a Saturday.</p>
</div>
<div id="exploring-wedding-dates-and-anniversaries" class="section level1">
<h1>Exploring Wedding Dates and Anniversaries</h1>
<p>Since Iâ€™ll be working with dates the <code>lubridate</code> package will be the workhorse for preparing my data.</p>
<pre class="r"><code>library(tidyverse) #Data Manipulation
library(lubridate) #Working with Dates
library(glue) # A package that works similar to the paste function
library(eulerr) # A package to create Venn-Diagrams (technically Euler Diagrams)</code></pre>
<p>In order to make the universe of wedding dates tractable Iâ€™ll be looking at all potential dates occurring on a Saturday in the past 10 years (since 1/1/2010) and through the next 5 years (through 12/31/2025). The <code>seq.Date()</code> function from the <code>lubridate</code> package makes generating sets of dates super easy. It works similar to <code>seq()</code> where you give it a starting point, and ending point but in this case you also provide the interval (â€˜dayâ€™, â€˜monthâ€™, â€˜yearâ€™, etc.).</p>
<p>In the following code block, Iâ€™m constructing a tibble with a column called <em>wedding_date</em> that is all days between 1/1/2010 and 12/31/2025 using the <code>ymd()</code> function from <code>lubridate</code> to turn the integers into a date. Then Iâ€™m creating a column called <em>wedding_date_day</em> that uses the <code>wday()</code> function from <code>lubridate</code> to return the day of the week. The â€œabbrâ€ and â€œlabelâ€ options have it return â€œMonâ€, â€œTueâ€, â€œWedâ€ rather than integer values which is the default (this is in part because I constantly forget whether 1 refers to Sunday or Mondayâ€¦ so this eliminates that problem). Finally, I keep only dates that are Saturdays and remove leap days since those will get weird as we look at annual anniversaries.</p>
<pre class="r"><code>wedding_dates &lt;- tibble(
  wedding_date = seq.Date(ymd(20100101), ymd(20251231), by = &#39;day&#39;),
  wedding_date_day = wday(wedding_date, abbr = T, label = T)
) %&gt;% 
  #Keep only Saturdays
  filter(wedding_date_day == &#39;Sat&#39;) %&gt;% 
  #Remove Leap Years because they&#39;re unique
  filter(!(day(wedding_date)==29 &amp; month(wedding_date) == 2))</code></pre>
<p>This will create a tibble with 834 rows representing all Saturdays between 2010 and 2025.</p>
<div id="counting-the-number-of-saturday-anniversaires-and-big-saturday-anniversaries" class="section level2">
<h2>Counting the Number of Saturday Anniversaires and â€œBigâ€ Saturday Anniversaries</h2>
<p>I will look at the first 50 years of marriage for any of these wedding dates. So for each of the 834 potential wedding dates I need to:</p>
<ol style="list-style-type: decimal">
<li>Calculate the day of week for each anniversary for the next 50 years</li>
<li>For each wedding date, count the number of anniversaries that fall on a Saturday</li>
<li>For each wedding date, count the number of â€œbigâ€ anniversaries that fall on a Saturday (again, â€œbigâ€ anniversaries being multiples of 5 such as 5th, 10th, â€¦)</li>
</ol>
<p>At first I really wanted to figure out a way to do this in a wide-format using <code>map</code> functions or <code>rowwise</code> functions, but in the end I couldnâ€™t figure it out in the time I wanted to spend exploring. Therefore, Iâ€™m keeping the data in a long-format by using <code>tidyr::crossing()</code> to expand each wedding days by the 50 anniversaries. So in the end each row in the initial data set will now have 50 rows.</p>
<p>Then for each of the Wedding Date/Anniversary Year combinations, I re-use the <code>wday()</code> function to get the day of the week and then <code>group_by</code> the wedding date and <code>summarize()</code> to count the number of Saturday anniversaries (<em>num_sat</em>) and â€œbigâ€ Saturday anniversaries (<em>num_big_sat</em>).</p>
<p>The two non-typical parts of this code block are the <code>.groups</code> argument to <code>summarize()</code> and the use of <code>paste()</code> in the <code>summarize()</code>. The <code>.groups</code> argument returns an ungrouped tibble rather than only removing the last grouping layer which is the default (this would have returned a grouped tibble with <em>wedding_date</em> as the grouping variableâ€¦ which would probably be fine but occasionally grouped tibbles cause downstream issues).</p>
<p>Using <code>paste()</code> in the <code>summarize()</code> with the <code>collapse=','</code> argument creates a concatenated comma-space separated string of the â€œbigâ€ anniversary years that fall on a Saturday and <code>NA</code> otherwise. The use of <code>stringr::str_remove_all()</code> is to remove the NAs from the string.</p>
<p>If youâ€™re reading this and are unfamiliar with regular expressions, I highly recommend getting familiar with them, especially when working with text. The regular expression â€œNA,? ?â€ means to remove the pattern â€œNAâ€ followed by 0 or 1 commas followed by 0 or 1 spaces. But the TL;DR here is that when a â€œbigâ€ anniversary didnâ€™t fall on a Saturday the string â€œNAâ€ would be concatenated and I wanted to remove those. So â€œ5, NA, NA, NA, 45, NAâ€ would just become â€œ5, 45,â€. Not ideal.. but itâ€™ll do.</p>
<pre class="r"><code>wedding_dates_w_annv &lt;- wedding_dates %&gt;% 
  #Expand Each Date to Have 50 Anniversaries
  crossing(anniversary = 1:50) %&gt;% 
  #Get the Day of Week for Those Anniversaries
  mutate(anniversary_day = wday(wedding_date + years(anniversary), label = T, abbr = T)) %&gt;% 
  #Summarize By Wedding Date counting the number of saturdays, number of saturdays w/ meaningful anniversary
  group_by(wedding_date, wedding_date_day) %&gt;% 
  summarize(
    num_sat = sum(anniversary_day == &#39;Sat&#39;),
    num_big_sat = sum(anniversary_day == &#39;Sat&#39; &amp; anniversary %% 5 == 0),
    #Building a string of all meaningful anniversary years,
    big_sat_years = str_remove_all(
      paste(
        if_else(anniversary_day == &#39;Sat&#39; &amp; anniversary %% 5 == 0, 
                anniversary, 
                NA_integer_
                ), 
        collapse = &#39;, &#39;), 
      &quot;NA,? ?&quot;),
    .groups = &#39;drop&#39;
  )</code></pre>
<p>Post-processing the data looks like:</p>
<table>
<thead>
<tr class="header">
<th align="center">wedding_date</th>
<th align="center">wedding_date_day</th>
<th align="center">num_sat</th>
<th align="center">num_big_sat</th>
<th align="center">big_sat_years</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">2010-01-02</td>
<td align="center">Sat</td>
<td align="center">7</td>
<td align="center">1</td>
<td align="center">45,</td>
</tr>
<tr class="even">
<td align="center">2010-01-09</td>
<td align="center">Sat</td>
<td align="center">7</td>
<td align="center">1</td>
<td align="center">45,</td>
</tr>
<tr class="odd">
<td align="center">2010-01-16</td>
<td align="center">Sat</td>
<td align="center">7</td>
<td align="center">1</td>
<td align="center">45,</td>
</tr>
</tbody>
</table>
<div id="how-many-big-saturday-anniversaries-does-anyone-get" class="section level3">
<h3>How many â€œBigâ€ Saturday Anniversaries Does Anyone Get?</h3>
<p>The first question to explore is for the 834 Saturdays in our data as potential wedding dates, how many of the â€œbigâ€ anniversaries will fall on a Saturday. The following code block is pretty vanilla <code>dplyr</code> with the use of <code>count()</code> and <code>mutate()</code>. If youâ€™ve never seen the <code>glue()</code> package and function before, it works a lot like <code>paste()</code> in its most basic form. The main difference is that R will execute the code within the <code>{ }</code> so it can be included directly within the quotes rather than separated by commas. It can also be used similar to <code>.format()</code> in Python.</p>
<pre class="r"><code>wedding_dates_w_annv %&gt;% 
  # Get frequencies of Big Saturday Anniversaries
  count(num_big_sat) %&gt;% 
  # Create %s 
  mutate(pct = n/sum(n)) %&gt;% 
  ggplot(aes(x = as.factor(num_big_sat), y = pct, fill = as.factor(num_big_sat))) +
    geom_col() + 
    geom_text(aes(label = glue(&quot;{pct %&gt;% scales::percent()} (n={n %&gt;% scales::comma()})&quot;)), nudge_y = 0.02) + 
    labs(title = &quot;How many ***BIG*** anniversaries are celebrated on Saturday?&quot;,
         subtitle = glue(&quot;Saturday Wedding Dates 2010 - 2025 (n = {nrow(wedding_dates_w_annv)})&quot;),
         caption = &quot;Big = Multiple of 5 (5th, 10th, etc.)&quot;,
         x = &quot;# of Big Anniversaries on Saturdays&quot;,
         y = &quot;% of Wedding Dates&quot;) + 
    scale_fill_discrete(guide = F) + 
    cowplot::theme_cowplot() + 
    theme(
      plot.title = ggtext::element_markdown(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank()
    )</code></pre>
<p><img src="/post/2020-10-01-what-s-the-best-day-to-get-married/index_files/figure-html/plot_num_big_saturdays-1.png" width="672" /></p>
<p>The primary reason there <strong>isnâ€™t</strong> a best or worst wedding date is that all potential wedding dates either have 1 or 2 <strong>BIG</strong> anniversaries on a Saturday. So there isnâ€™t too much of a difference in choice of dates.</p>
<p>So letâ€™s look at how many anniversaries in total occur on a Saturday.</p>
</div>
<div id="how-many-total-saturday-anniversaries-does-anyone-get" class="section level3">
<h3>How many total Saturday Anniversaries Does Anyone Get?</h3>
<pre class="r"><code>wedding_dates_w_annv %&gt;% 
  count(num_sat) %&gt;% 
  mutate(pct = n/sum(n)) %&gt;% 
  ggplot(aes(x = as.factor(num_sat), y = pct, fill = as.factor(num_sat))) +
  geom_col() + 
  geom_text(aes(label = glue(&quot;{pct %&gt;% scales::percent()} (n={n %&gt;% scales::comma()})&quot;)), nudge_y = 0.02) + 
  labs(title = &quot;How many anniversaries are celebrated on Saturday?&quot;,
       subtitle = glue(&quot;Saturday Wedding Dates 2010 - 2025 (n = {nrow(wedding_dates_w_annv)})&quot;),
       x = &quot;# of Anniversaries on Saturdays&quot;,
       y = &quot;% of Wedding Dates&quot;) + 
  scale_fill_discrete(guide = F) + 
  cowplot::theme_cowplot() + 
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )</code></pre>
<p><img src="/post/2020-10-01-what-s-the-best-day-to-get-married/index_files/figure-html/plot_num_total_saturday-1.png" width="672" /></p>
<p>Continuing with the theme of there not being major differences. 75% of Saturday Wedding dates will have 7 anniversaries on a Saturday and 25% will have 6. So, while 7 would be preferable, the difference between 7 vs.Â 6 again is not large.</p>
</div>
<div id="looking-at-both-total-saturdays-and-big-saturdays" class="section level3">
<h3>Looking at Both Total Saturdays and â€œBigâ€ Saturdays</h3>
<p>Since â€œBigâ€ Anniversaries had a 50/50 distribution and overall Saturdays had a 25/75 distribution the next step would be to see the cross-product of the two previous fields:</p>
<pre class="r"><code>wedding_dates_w_annv %&gt;% 
  count(num_sat, num_big_sat) %&gt;% 
  mutate(pct = n / sum(n)) %&gt;% 
  ggplot(aes(x = factor(num_sat), y = factor(num_big_sat), fill = pct)) + 
    geom_tile() + 
    geom_text(aes(label = glue(&quot;{pct %&gt;% scales::percent()} \n (n={n})&quot;))) + 
    labs(title = &quot;A deeper look into Saturday Anniversaries&quot;,
         subtitle = glue(&quot;Saturday Wedding Dates 2010 - 2025 (n = {nrow(wedding_dates_w_annv)})&quot;),
         x = &quot;# of Anniversaries on Saturdays&quot;,
         y = &quot;# of &#39;Big&#39; Anniversaries on Saturday&quot;) + 
    scale_fill_gradient(guide = F, low = &quot;#769293&quot;, high = &quot;#fad7d5&quot;) +
    cowplot::theme_cowplot()</code></pre>
<p><img src="/post/2020-10-01-what-s-the-best-day-to-get-married/index_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<p>Looking across both dimensions, everyone who has two â€œbigâ€ anniversaries on a Saturday ALSO has 7 anniversaries on a Saturday. However, not everyone who has 7 anniversaries on Saturday will have 2 â€œbigâ€ anniversaries on a Saturday. Instead there are three groups:</p>
<ul>
<li>6 Total / 1 Big (25%)</li>
<li>7 Total / 1 Big (25%)</li>
<li>7 Total / 2 Big (50%)</li>
</ul>
<p>In this case, having 7 anniversaries and 2 â€œBigâ€ Anniversaries seems preferable to the other two groupsâ€¦ if you only cared about having your anniversary on a Saturday.</p>
</div>
<div id="what-big-anniversaries-will-be-celebrated-on-saturdays" class="section level3">
<h3>What â€œBigâ€ Anniversaries Will Be Celebrated on Saturdays?</h3>
<p>So far, Iâ€™ve defined â€œbigâ€ anniversaries as multiples of 5 (5th, 10th, â€¦ 45th, 50th). However, I havenâ€™t looked at which of those big ones are occurring on a Saturday. To show these â€œbigâ€ anniversaries Iâ€™ll use the <code>eulerr</code> package to create a Venn-Diagram of these years.</p>
<p>The package expects a specific format where each column is a logical indicating whether or not an observation is a member of that group. From a quick check on the <em>big_sat_years</em> field I can see that the only â€œbigâ€ anniversaries that fall on Saturdays are the 5th, 45th, and 50th.</p>
<p>Of note is the regular expression â€œ\b5\bâ€ for identifying the 5th anniversary. <code>\\b</code> represents a word boundary so it is included to make sure that the 5th anniversary doesnâ€™t accidentally get picked up by <code>str_detect()</code> as part of 45 or 50, which would occur if I only searched for â€œ5â€.</p>
<pre class="r"><code>wedding_dates_w_annv %&gt;% 
  #Constructing Logicals for Venn Diagrams
  transmute(
    `5th \n Anniversary` = str_detect(big_sat_years, &#39;\\b5\\b&#39;),
    `45th \n Anniversary` = str_detect(big_sat_years, &#39;45&#39;),
    `50th \n Anniversary` = str_detect(big_sat_years, &#39;50&#39;)
  ) %&gt;%
  #Plot the Venn-Diagram
  euler() %&gt;% 
  plot(quantities = list(type = c(&#39;counts&#39;, &#39;percent&#39;)),
       percentages = TRUE,
       main = &quot;Which &#39;big&#39; anniversaries get celebrated on Saturdays?&quot;,
       )</code></pre>
<p><img src="/post/2020-10-01-what-s-the-best-day-to-get-married/index_files/figure-html/venn_diagram_big_anniversaries-1.png" width="672" /></p>
<p>So 75% of wedding dates will celebrate their 45th anniversary on a Saturday. 50% will celebrate ONLY their 45th anniversary and 25% will celebrate their 45th and 50th anniversaries on a Saturday. The last 25% will celebrate their 5th and 50th anniversary on a Saturday. No one will ONLY celebrate either their 5th or 50th. Fitting this into our three group paradigm from the prior section:</p>
<ul>
<li>6 Total / 1 Big (25%) - Will <strong>ONLY</strong> celebrate their 45th Anniversary</li>
<li>7 Total / 1 Big (25%) - Will <strong>ONLY</strong> celebrate their 45th Anniversary</li>
<li>7 Total / 2 Big (50%)
<ul>
<li>25% will celebrate their 5th and 50th</li>
<li>25% will celebrate their 45th and 50th</li>
</ul></li>
</ul>
</div>
<div id="is-there-a-time-component-to-which-group-you-end-up-in" class="section level3">
<h3>Is there a time component to which group you end up in?</h3>
<p>This final section looks at the time component to whether you wind up in the 6/1, 7/1, or 7/2 group. In order to summarize to a Year/Month level, the average number of Saturdays and â€œBigâ€ Saturdays will be used. Then in the following heat-map, the year of the wedding date appears on the y-axis and the month of the wedding is on the x-axis.</p>
<pre class="r"><code>wedding_dates_w_annv %&gt;% 
  #Reformat to Year-Month (%Y = Year w/ Century, %m = Month as Zero-Padded Decimal)
  mutate(
    m = month(wedding_date),
    y = year(wedding_date),
  ) %&gt;% 
  group_by(m, y) %&gt;% 
  #Get Averages
  summarize(across(starts_with(&#39;num&#39;), mean), .groups = &#39;drop&#39;) %&gt;%
  mutate(grp = glue(&quot;{num_sat} Total / {num_big_sat} Big&quot;)) %&gt;% 
  ggplot(aes(x = factor(y), y = factor(m), fill = grp)) + 
  geom_tile() + 
  scale_fill_viridis_d(option = &quot;D&quot;) + 
  labs(x = &quot;Year of Wedding Date&quot;,
       y = &quot;Month of Wedding Date&quot;,
       title = &quot;Looking at # Saturdays / ***&#39;BIG&#39;*** Saturdays&quot;,
       fill = &quot;&quot;) + 
  cowplot::theme_cowplot() + 
  theme(plot.title = ggtext::element_markdown()) +
  coord_flip()</code></pre>
<p><img src="/post/2020-10-01-what-s-the-best-day-to-get-married/index_files/figure-html/time_dimension-1.png" width="672" /></p>
<p>There appears to be a reproducible pattern to which of the three groups youâ€™ll wind up in based on the initial wedding date. Probably not surprisingly this occurs in a 4 year cycle.</p>
<ul>
<li>6 Total / 1 Big - Starts in March after a leap year and continues for the next 12 months.
<ul>
<li>Examples: Mar 2012-Feb 2013, Mar 2016-Feb 2017, Mar 2020-Feb 2021</li>
</ul></li>
<li>7 Total / 1 Big - The following <strong>12</strong> months after the first group
<ul>
<li>Examples: Mar 2013-Feb 2014, Mar 2017-Feb 2018, Mar 2021-Feb 2022</li>
</ul></li>
<li>7 Total / 2 Big - The following <strong>24</strong> months after the second group
<ul>
<li>Examples: Mar 2014-Feb 2016, Mar 2018-Feb 2020, Mar 2022-Feb 2024</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>Weddings (or the choice not to have one) are personal decisions for which there is no right or wrong. <strong><em>HOWEVER</em></strong>, if you should choose to require to have your wedding on a Saturday and want to maximize the number of anniversaries you celebrate on Saturday as well as the number the â€œbigâ€ anniversaries celebrated on Saturdays then youâ€™d do well to avoid the 24 months after leap-day.</p>
<p>But the differences between the three groups identified here are pretty small. So while the original question was what are the best and worst days to get married the good answer is that it really doesnâ€™t matter!</p>
</div>
